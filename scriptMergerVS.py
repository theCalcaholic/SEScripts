import re
import os
import codecs
import sys

parselib_path = "C:\\Users\\Tobias\\informatics\\SEScripts\\SEScripts\\ParseLib\\"

preamble = """/*****************************************************************
This file is automatically generated. Don't change it's content;
such changes will be overwritten on next build.
*****************************************************************/
"""

parselib_header = """using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;

using VRageMath;
using VRage.Game;
using VRage.Collections;
using Sandbox.ModAPI.Ingame;
using VRage.Game.Components;
using VRage.Game.ModAPI.Ingame;
using Sandbox.ModAPI.Interfaces;
using Sandbox.Game.EntityComponents;
using SpaceEngineers.Game.ModAPI.Ingame;
using VRage.Game.ObjectBuilders.Definitions;

using SEScripts.Lib.LoggerNS;

namespace """

generic_header = """namespace SEScripts.Merged
{
"""

generic_footer = """
}"""

class ScriptProvider:
  def __init__(self, root_namespace, root_path):
    self.scripts = dict()
    self.namespace = root_namespace
    self.path = os.path.abspath(root_path)

  def get_path_from_namespace(self, namespace):
    relative_namespace = namespace.replace(self.namespace + ".", "")
    namespace_split = relative_namespace.split(".")
    path = os.path.join(self.path, os.path.join(*namespace_split))
    return path

  def get_script(self, namespace, no_dirs):
    if namespace in self.scripts:
      return self.scripts[namespace]
    embed_path = self.get_path_from_namespace(namespace)
    embed_text = ""
    if not os.path.exists(embed_path) and not os.path.exists(embed_path + ".cs"):
      #console.write("WARNING: No file or directory found for " + namespace + "\n")
      print("WARNING: No file or directory found for " + namespace + "\n")
    elif os.path.isdir(embed_path) and not no_dirs:
      #console.write("embed is dir\n")
      embed_text = ""
      for subdir in os.listdir(embed_path):
        embed_text += this.get(os.join(embed_path, subdir))
    elif os.path.isfile(embed_path + ".cs"):
      #console.write("embed is file\n")
      text = ""
      with open(embed_path + ".cs", encoding='utf-8-sig', mode='r') as f:
        text = f.read()

      regexHeader = re.compile(r'.*namespace\s*?(?P<namespace>[\w.]+)\s*{', flags=re.DOTALL | re.UNICODE)
      matches = regexHeader.search(text)
      parent_namespace = matches.group("namespace")
      embed_text = text[matches.end():text.rfind("}")]
      self.scripts[namespace] = embed_text

    return embed_text

  def build(self, namespace):
    #console.write("build()\n")
    print("build()\n")
    file_path = self.get_path_from_namespace(namespace)
    build_dir = os.path.join(os.path.dirname(file_path), "Build")
    file_base_name = os.path.basename(file_path)
    build_base_name = file_base_name.replace("WRAPPER", "")
    build_path = os.path.join(build_dir,  build_base_name + ".cs")
    content = self.build_rec(namespace)
    """wrapperRegex = re.compile(r'\w+WRAPPER', flags=re.UNICODE)
    if file_base_name != build_base_name:
      content = content.replace(file_base_name, build_base_name)"""
    parselib_namespace = namespace[namespace.find(".") + 1:namespace.rfind(".")]
    content = minify(content)
    parselib_content = parselib_header + "SEScripts.ParseLib." + parselib_namespace + " {\n" + preamble + content + generic_footer

    if not os.path.isdir(build_dir):
      os.makedirs(build_dir)
    with open(build_path, "w", encoding='utf-8-sig') as file:
      print("Saving raw file at: <" + build_path)
      file.write(generic_header + content + generic_footer)

    if not os.path.isdir(parselib_path):
      os.makedirs(parselib_path)
    with open(os.path.join(parselib_path, build_base_name + ".cs"), "w", encoding='utf-8-sig') as file:
      print("Saving parseLib file at: <" + os.path.join(parselib_path,build_base_name + ".cs"))
      file.write(parselib_content)
    return content


  def build_rec(self, namespace):
    print("build script " + namespace + "\n")
    print("=======================================================\n")
    content = self.get_script(namespace, True)

    regex = re.compile(r'(?<=(//EMBED ))\S+')
    prematch_length = len("//EMBED ")
    match = regex.search(content)

    while match != None:
      dep_namespace = match.group(0).strip()
      if(not dep_namespace in self.scripts):
        dep_content = self.build_rec(dep_namespace)
      else:
        dep_content = ""
      content = content[:match.start(0) - prematch_length] + dep_content + content[match.end(0) + 1:]
      match = regex.search(content)

    name = namespace[namespace.rfind(".") + 1:]
    if name[-7:] == "WRAPPER":
      content = content.replace(name, name[:-7])
    content = content.replace("//UNCOMMENT ", "")
    print("-------------------------------------------------------\n")
    return content

def minify(text):

  minified_text = ""
  for line in text.splitlines():
    if len(line) != 0:
      minified_text += line.strip() + "\n"
  minified_text = minified_text.replace("\n\r", "\n")
  return minified_text

print("arg1: " + sys.argv[0])
print("arg2: " + sys.argv[1])
print("arg3: " + sys.argv[2])
print("arg4: " + sys.argv[3])


if not len(sys.argv) == 4:
  print("You're doing it wrong!")
else:
  root_path = sys.argv[1]
  root_namespace = sys.argv[2]
  build_file = sys.argv[3].replace(os.path.dirname(os.path.normpath(root_path)), "").replace("\\", ".").strip(".")
  if build_file[-3:] == ".cs" or build_file[-3:] == ".CS":
    build_file = build_file[:-3]
  print("root_path: " + root_path)
  print("root_namespace: " + root_namespace)
  print("build_file: " + build_file)

  ScriptStore = ScriptProvider(root_namespace, root_path)
  ScriptStore.build(build_file)
  print("build finished")

