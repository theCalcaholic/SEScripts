using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

using VRageMath;
using VRage.Game;
using VRage.Collections;
using Sandbox.ModAPI.Ingame;
using VRage.Game.Components;
using VRage.Game.ModAPI.Ingame;
using Sandbox.ModAPI.Interfaces;
using Sandbox.Game.EntityComponents;
using SpaceEngineers.Game.ModAPI.Ingame;
using VRage.Game.ObjectBuilders.Definitions;

using SEScripts.Lib.LoggerNS;
using SEScripts.XUI.BoxRenderer;

namespace SEScripts.ParseLib.XUI.XML {
/*****************************************************************
This file is automatically generated. Don't change it's content;
such changes will be overwritten on next build.
*****************************************************************/
public class TextInput : XMLTree
{
int CursorPosition;
public TextInput()
{
//Logger.log("TextInput constructor()");
//Logger.IncLvl();
Type = "textinput";
Selectable = true;
CursorPosition = -1;
PreventDefault("LEFT/ABORT");
PreventDefault("RIGHT/SUBMIT");
SetAttribute("maxlength", "10");
SetAttribute("value", "");
SetAttribute("allowedchars", " a-z0-9");
//Logger.DecLvl();
}
public override void OnKeyPressed(string keyCode)
{
switch (keyCode)
{
case "LEFT/ABORT":
DecreaseCursorPosition();
break;
case "RIGHT/SUBMIT":
IncreaseCursorPosition();
break;
case "UP":
DecreaseLetter();
break;
case "DOWN":
IncreaseLetter();
break;
default:
base.OnKeyPressed(keyCode);
break;
}
}
public override void SetAttribute(string key, string value)
{
if(key == "allowedchars")
{
if(!System.Text.RegularExpressions.Regex.IsMatch(value,
@"([^-\\]-[^-\\]|[^-\\]|\\-|\\\\)*"))
{
throw new Exception("Invalid format of allowed characters!");
}

}
//if (key == "value")
//using (new Logger("set value: " + value)) { }
base.SetAttribute(key, value);
}
private void IncreaseLetter()
{
//Logger.log("TextInput.IncreaseLetter()");
//Logger.IncLvl();
if (CursorPosition == -1)
{
return;
}
char[] value = GetAttribute("value").ToCharArray();
char letter = value[CursorPosition];
string[] charSets = GetAllowedCharSets();
for (int i = 0; i < charSets.Length; i++)
{
if ((charSets[i].Length == 1 && charSets[i][0] == value[CursorPosition])
|| (charSets[i].Length == 3 && charSets[i][2] == value[CursorPosition]))
{
//Logger.log("letter outside class, setting to: " + charSets[i == 0 ? charSets.Length - 1 : i - 1][0] + ". (chars[" + ((i + 1) % charSets.Length) + "])");
value[CursorPosition] = charSets[(i + 1) % charSets.Length][0];
SetAttribute("value", new string(value));
//Logger.DecLvl();
return;
}
}
//Logger.log("letter inside class, setting to: " + (char)(((int)value[CursorPosition]) + 1));
value[CursorPosition] = (char)(((int)value[CursorPosition]) + 1);
SetAttribute("value", new string(value));
//Logger.DecLvl();
}
private void DecreaseLetter()
{
//Logger.log("TextInput.DecreaseLetter()");
//Logger.IncLvl();
if (CursorPosition == -1)
{
return;
}
char[] value = GetAttribute("value").ToCharArray();
char[] chars = GetAttribute("allowedchars").ToCharArray();
string[] charSets = GetAllowedCharSets();
for(int i = 0; i < charSets.Length; i++)
{
if(charSets[i][0] == value[CursorPosition])
{
int index = (i == 0 ? charSets.Length - 1 : i - 1);
//Logger.log("letter outside class, setting to: " + charSets[index][charSets[index].Length - 1] + ". (chars[" + (index) + "])");
value[CursorPosition] = charSets[index][charSets[index].Length - 1];
SetAttribute("value", new string(value));
return;
}
}
//Logger.log("letter inside class, setting to: " + (char)(((int)value[CursorPosition]) - 1));
value[CursorPosition] = (char)(((int)value[CursorPosition]) - 1);
SetAttribute("value", new string(value));
//Logger.DecLvl();
}
private string[] GetAllowedCharSets()
{
string charString = GetAttribute("allowedchars");
System.Text.RegularExpressions.MatchCollection matches =
System.Text.RegularExpressions.Regex.Matches(charString, @"[^-\\]-[^-\\]|[^-\\]|\\-|\\\\");
string[] charSets = new string[matches.Count];
int i = 0;
foreach (System.Text.RegularExpressions.Match match in matches)
{
string matchString = match.ToString();
if (matchString == "\\-")
{
charSets[i] = "-";
}
else if (matchString == "\\\\")
{
charSets[i] = "\\";
}
else
{
charSets[i] = matchString;
}
i++;
}
//P.Echo("Char sets found: " + string.Join(",", charSets));
return charSets;
}
private void IncreaseCursorPosition()
{
if (CursorPosition < Single.Parse(GetAttribute("maxlength")) - 1)
{
CursorPosition++;
}
else
{
CursorPosition = 0;
DecreaseCursorPosition();
KeyPress("DOWN");
}
if (CursorPosition != -1)
{
PreventDefault("UP");
PreventDefault("DOWN");
}
if (CursorPosition >= GetAttribute("value").Length)
{
string[] charSets = GetAllowedCharSets();
SetAttribute("value", GetAttribute("value") + charSets[0][0]);
}
}
private void DecreaseCursorPosition()
{
if (CursorPosition > -1)
{
CursorPosition--;
}
if (CursorPosition == -1)
{
AllowDefault("UP");
AllowDefault("DOWN");
}
}
/*protected override void RenderText(ref List<string> segments, int width, int availableWidth)
{
string value = GetAttribute("value");
if (CursorPosition != -1)
{
value = value.Substring(0, CursorPosition)
+ "|" + value.Substring(CursorPosition, 1) + "|"
+ value.Substring(CursorPosition + 1);
}
else if (value.Length == 0)
{
value = "_" + value;
}
segments.Add((IsSelected() ? new string(new char[] { (char)187 }) : "  ") + " " + value);
}*/
public override IRenderBox GetRenderBox(int containerWidth, int containerHeight)
{
//using (Logger logger = new Logger("TextInput.GetRenderCache(int)", Logger.Mode.LOG))
//{
RenderBoxTree cache = new RenderBoxTree();
UpdateRenderCacheProperties(cache, containerWidth, containerHeight);
RenderBoxLeaf content = new RenderBoxLeaf();
cache.type = Type;
cache.Flow = IRenderBox.FlowDirection.HORIZONTAL;
cache.Add(content);
content.Add((IsSelected() ? new string(new char[] { (char)187 }) : " ") + " ");
content.MinWidth = TextUtils.GetTextWidth(new string(new char[] { (char)187, ' ' }));
string value = GetAttribute("value");
//logger.log("value: " + value, Logger.Mode.LOG);
if (CursorPosition != -1)
{
content.Add(value.Substring(0, CursorPosition));
content.Add("|");
content.Add(value.Substring(CursorPosition, 1));
content.Add("|");
content.Add(value.Substring(CursorPosition + 1));
}
else
{
if (value.Length == 0)
content.Add("_");
content.Add(value);
}
/*
for(int i = 0; i < cache.Count; i++)
{
cache[i].MaxWidth = cache[i].MinWidth;
}*/
return cache;
}
//}
}

public abstract class DataStore : XMLTree
{
public DataStore() : base() { }
public override Dictionary<string, string> GetValues(Func<XMLTree, bool> filter)
{
Dictionary<string, string> dict = base.GetValues(filter);
if (!filter(this))
{
return dict;
}
foreach (KeyValuePair<string, string> data in Attributes)
{
if (!dict.ContainsKey(data.Key))
{
dict[data.Key] = data.Value;
}
}
return dict;
}
}

public abstract class XMLTree : XMLParentNode
{
public string Type;
private XMLParentNode Parent;
private List<string> PreventDefaults;
protected List<XMLTree> Children;
protected bool Selectable;
protected bool ChildrenAreSelectable;
private bool Selected;
protected int SelectedChild;
protected bool Activated;
protected Dictionary<string, string> Attributes;
private bool _hasUserInputBindings;
private IRenderBox _renderCache;
public bool HasUserInputBindings
{
get { return _hasUserInputBindings; }
set
{
_hasUserInputBindings = value;
if(Parent != null && HasUserInputBindings)
{
Parent.HasUserInputBindings = true;
}
}
}
public int NumberOfChildren
{
get
{
return Children.Count;
}
}
protected bool RerenderRequired;
public virtual IRenderBox GetRenderBox(int containerWidth, int containerHeight)
{
//using (Logger logger = new Logger("XMLTree<" + Type + ">.GetRenderBox(int, int)", Logger.Mode.LOG))
//{
//Logger.debug("XMLTree.GetRenderCache(int)");
//Logger.IncLvl();
/*if(_renderCache != null)
{
return _renderCache;
}*/
RenderBoxTree cache = new RenderBoxTree();
cache.type = Type;
UpdateRenderCacheProperties(cache, containerWidth, containerHeight);
//Console.WriteLine(Type);
//logger.log("1", Logger.Mode.LOG);
IRenderBox childCache;
IRenderBox.TextAlign align;

foreach (XMLTree child in Children)
{
//TODO: Problems with relative height/width values
childCache = child.GetRenderBox(Math.Max(cache._DesiredWidth, cache._MinWidth), Math.Max(cache._DesiredHeight, cache._MinHeight));
if (child.GetAttribute("alignself") == null
&& Enum.TryParse<IRenderBox.TextAlign>(GetAttribute("alignchildren")?.ToUpper() ?? "LEFT", out align))
childCache.Align = align;
//logger.log("-", Logger.Mode.LOG);
cache.Add(childCache);

}
//logger.log("2", Logger.Mode.LOG);
//_renderCache = cache;
return cache;
//}
}
protected void UpdateRenderCacheProperties(IRenderBox cache, int containerWidth, int containerHeight)
{
//using (Logger logger = new Logger("XMLTree<" + Type + ">.UpdateRenderCacheProperties(NodeBox, int)", Logger.Mode.LOG))
//{
//logger.log("containerWidth: " + containerWidth);
//logger.log("containerHeight: " + containerHeight);
cache.Flow = GetAttribute("flow") == "horizontal" ? IRenderBox.FlowDirection.HORIZONTAL : IRenderBox.FlowDirection.VERTICAL;
switch (GetAttribute("alignself"))
{
case "right":
cache.Align = IRenderBox.TextAlign.RIGHT;
break;
case "center":
cache.Align = IRenderBox.TextAlign.CENTER;
break;
default:
cache.Align = IRenderBox.TextAlign.LEFT;
break;
}
cache.MinWidth = Math.Max(0, ResolveSize(GetAttribute("minwidth"), containerWidth) ?? 0);
cache.MaxWidth = ResolveSize(GetAttribute("maxwidth"), containerWidth) ?? int.MaxValue;
cache.DesiredWidth = ResolveSize(GetAttribute("width"), containerWidth) ?? -1;
int forcedWidth = ResolveSize(GetAttribute("forcewidth"), containerWidth) ?? -1;
if (forcedWidth != -1)
{
cache.MinWidth = forcedWidth;
cache.MaxWidth = forcedWidth;
}
cache.MinHeight = Math.Max(0, ResolveSize(GetAttribute("minheight"), containerHeight) ?? 0);
cache.MaxHeight = ResolveSize(GetAttribute("maxheight"), containerHeight) ?? int.MaxValue;
cache.DesiredHeight = ResolveSize(GetAttribute("height"), containerHeight) ?? -1;
int forcedHeight = ResolveSize(GetAttribute("forceheight"), containerHeight) ?? -1;
if (forcedHeight != -1)
{
//logger.log("Apply forced height (" + forcedHeight + ")", Logger.Mode.LOG);
cache.MinHeight = forcedHeight;
cache.MaxHeight = forcedHeight;
}
//cache.Height = CalculateWidth(GetAttribute("height"), -1);
//}
}
public static int? ResolveSize(string widthString, int containerWidth)
{
//using (Logger logger = new Logger("XMLTree.ResolvePercentage(string, int)", Logger.Mode.LOG))
//{
if (widthString == null)
return null;
widthString = widthString?.Trim();
if (widthString != null && widthString[widthString.Length - 1] == '%' && Single.TryParse(widthString.Substring(0, widthString.Length - 1), out float fWidth))
{
if (containerWidth == -1 || containerWidth == int.MaxValue)
return null;
return (int)(fWidth / 100f * Math.Max(0, containerWidth));
}
else
{
int iWidth = -1;
if (Int32.TryParse(widthString, out iWidth))
return iWidth;
return null;
}
//}
}
public XMLTree()
{
//using (Logger logger = new Logger("XMLTree constructor", Logger.Mode.LOG))
//{
HasUserInputBindings = false;
PreventDefaults = new List<string>();
Parent = null;
Children = new List<XMLTree>();
Selectable = false;
ChildrenAreSelectable = false;
Selected = false;
SelectedChild = -1;
Activated = false;
Attributes = new Dictionary<string, string>();
RerenderRequired = true;
Type = "NULL";
// set attribute defaults
//SetAttribute("alignself", "left");
SetAttribute("selected", "false");
SetAttribute("selectable", "false");
SetAttribute("flow", "vertical");
//}
}
public bool IsSelectable()
{
//Logger.debug(Type + ": IsSelectable():");
//Logger.IncLvl();
//Logger.DecLvl();
return Selectable || ChildrenAreSelectable;
}
public bool IsSelected()
{
//Logger.debug(Type + ": IsSelected():");
//Logger.IncLvl();
//Logger.DecLvl();
return Selected;
}
public XMLTree GetSelectedSibling()
{
//Logger.debug(Type + ": GetSelectedSibling():");
//Logger.IncLvl();
if (!Selected)
{
//Logger.DecLvl();
return null;
//throw new Exception(
//    "Node is not selected. You can only get the selected Node from one of it's parent nodes!");
}
if (SelectedChild == -1)
{
//Logger.DecLvl();
return this;
}
else
{
//Logger.DecLvl();
return Children[SelectedChild].GetSelectedSibling();
}
}
public virtual void AddChild(XMLTree child)
{
//Logger.debug(Type + ": AddChild():");
//Logger.IncLvl();
AddChildAt(Children.Count, child);
//Logger.DecLvl();
}
public virtual void AddChildAt(int position, XMLTree child)
{
//Logger.debug(Type + ":AddChildAt()");
//Logger.IncLvl();
if( position > Children.Count )
{
throw new Exception("XMLTree.AddChildAt - Exception: position must be less than number of children!");
}
RerenderRequired = true;
Children.Insert(position, child);
child.SetParent(this as XMLParentNode);
UpdateSelectability(child);
//Logger.DecLvl();
}
public void SetParent(XMLParentNode parent)
{
//Logger.debug(Type + ": SetParent():");
//Logger.IncLvl();
Parent = parent;
if(HasUserInputBindings && Parent != null)
{
Parent.HasUserInputBindings = true;
}
//Logger.DecLvl();
}
public XMLParentNode GetParent()
{
//Logger.debug(Type + ": GetParent():");
//Logger.IncLvl();
//Logger.DecLvl();
return Parent;
}
public XMLTree GetChild(int i)
{
//Logger.debug(Type + ": GetChild():");
//Logger.IncLvl();
//Logger.DecLvl();
return i < Children.Count ? Children[i] : null;
}
public XMLTree GetNode(Func<XMLTree, bool> filter)
{
if (filter(this))
{
return this;
}
else
{
XMLTree child = GetChild(0);
XMLTree childResult;
for (int i = 1; child != null; i++)
{
childResult = child.GetNode(filter);
if (childResult != null)
{
return childResult;
}
child = GetChild(i);
}
}
return null;
}
public List<XMLTree> GetAllNodes(Func<XMLTree, bool> filter)
{
List<XMLTree> nodeList = new List<XMLTree>();
GetAllNodes(filter, ref nodeList);
return nodeList;
}
private void GetAllNodes(Func<XMLTree, bool> filter, ref List<XMLTree> nodeList)
{
if (filter(this))
{
nodeList.Add(this);
}
XMLTree child = GetChild(0);
for (int i = 1; child != null; i++)
{
child.GetAllNodes(filter, ref nodeList);
child = GetChild(i);
}
}
public virtual void UpdateSelectability(XMLTree child)
{
//Logger.debug(Type + ": UpdateSelectability():");
//Logger.IncLvl();
bool ChildrenWereSelectable = ChildrenAreSelectable;
ChildrenAreSelectable = ChildrenAreSelectable || child.IsSelectable();
if ((Selectable || ChildrenAreSelectable) != (Selectable || ChildrenWereSelectable))
{
RerenderRequired = true;
//Logger.debug("update parent selectability");
if(Parent != null)
Parent.UpdateSelectability(this);
//Logger.debug("parent selectability updated");
}
//Logger.DecLvl();
}
public bool SelectFirst()
{
//Logger.debug(Type + ": SelectFirst():");
//Logger.IncLvl();
if (SelectedChild != -1)
{
Children[SelectedChild].Unselect();
}
SelectedChild = -1;
bool success = (Selectable || ChildrenAreSelectable) ? SelectNext() : false;
//Logger.DecLvl();
return success;
}
public bool SelectLast()
{
//Logger.debug(Type + ": SelectLast():");
//Logger.IncLvl();
if (SelectedChild != -1)
{
Children[SelectedChild].Unselect();
}
SelectedChild = -1;
//Logger.DecLvl();
return (Selectable || ChildrenAreSelectable) ? SelectPrevious() : false;
}
public void Unselect()
{
//Logger.debug(Type + ": Unselect():");
//Logger.IncLvl();
if (SelectedChild != -1)
{
Children[SelectedChild].Unselect();
}
Selected = false;
Activated = false;
//Logger.DecLvl();
}
public virtual bool SelectNext()
{
//Logger.debug(Type + ": SelectNext():");
//Logger.IncLvl();
bool WasSelected = IsSelected();
if (SelectedChild == -1 || !Children[SelectedChild].SelectNext())
{
//Logger.debug(Type + ": find next child to select...");
SelectedChild++;
while ((SelectedChild < Children.Count && (!Children[SelectedChild].SelectFirst())))
{
SelectedChild++;
}
if (SelectedChild == Children.Count)
{
SelectedChild = -1;
Selected = Selectable && !Selected;
}
else
{
Selected = true;
}
}
if (!Selected)
{
Unselect();
}
if (!WasSelected && IsSelected())
{
OnSelect();
RerenderRequired = true;
}
//Logger.DecLvl();
return Selected;
}
public virtual bool SelectPrevious()
{
//Logger.debug(Type + ": SelectPrevious():");
//Logger.IncLvl();
bool WasSelected = IsSelected();
if (SelectedChild == -1) { SelectedChild = Children.Count; }
if (SelectedChild == Children.Count || !Children[SelectedChild].SelectPrevious())
{
SelectedChild--;
while (SelectedChild > -1 && !Children[SelectedChild].SelectLast())
{
SelectedChild--;
}
if (SelectedChild == -1)
{
Selected = Selectable && !Selected;
}
else
{
Selected = true;
}
}
if (!Selected)
{
Unselect();
}
if (!WasSelected && IsSelected())
{
OnSelect();
RerenderRequired = true;
}
//Logger.DecLvl();
return Selected;
}
public virtual void OnSelect() { }
public virtual string GetAttribute(string key)
{
//Logger.debug(Type + ": GetAttribute(" + key + "):");
//Logger.IncLvl();
if (Attributes.ContainsKey(key))
{
//Logger.DecLvl();
return Attributes[key];
}
else if( key == "flowdirection" && Attributes.ContainsKey("flow"))
{
return Attributes["flow"];
}
//Logger.DecLvl();
return null;
}
public virtual void SetAttribute(string key, string value)
{
//Logger.debug(Type + ": SetAttribute():");
//Logger.IncLvl();
if (key == "selectable")
{
bool shouldBeSelectable = value == "true";
if (Selectable != shouldBeSelectable)
{
Selectable = shouldBeSelectable;
if (Parent != null)
{
Parent.UpdateSelectability(this);
}
}
}
else if (key == "activated")
{
bool shouldBeActivated = value == "true";
Activated = shouldBeActivated;
}
else if(key == "inputbinding")
{
HasUserInputBindings = true;
if(Parent != null)
{
Parent.HasUserInputBindings = true;
}
}
else if (key == "flow")
{
if(value == "horizontal")
{
//RenderCach.Flow = NodeBox.FlowDirection.HORIZONTAL;
}
else
{
//base.Flow = NodeBox.FlowDirection.VERTICAL;
}
RerenderRequired = true;
}
else if (key == "align")
{
switch(value)
{
case "right":
//base.Align = NodeBox.TextAlign.RIGHT;
break;
case "center":
//base.Align = NodeBox.TextAlign.CENTER;
break;
default:
//base.Align = NodeBox.TextAlign.LEFT;
break;
}
RerenderRequired = true;
}
else if (key == "width")
{
int width;
if(Int32.TryParse(value, out width))
{
//base.DesiredWidth = width;
}
}
Attributes[key] = value;
//Logger.DecLvl();
}
public XMLParentNode RetrieveRoot()
{
XMLParentNode ancestor = this;
while (ancestor.GetParent() != null)
{
ancestor = ancestor.GetParent();
}
return ancestor;
}
public void KeyPress(string keyCode)
{
//Logger.debug(Type + ": _KeyPress():");
//Logger.IncLvl();
//Logger.debug("button: " + keyCode);
OnKeyPressed(keyCode);
if (Parent != null && !PreventDefaults.Contains(keyCode))
{
Parent.KeyPress(keyCode);
}
//Logger.DecLvl();
}
public virtual void OnKeyPressed(string keyCode)
{
//Logger.debug(Type + ": OnKeyPressed()");
//Logger.IncLvl();
switch (keyCode)
{
case "ACTIVATE":
ToggleActivation();
break;
default:
break;
}
//Logger.DecLvl();
}
public virtual void ToggleActivation()
{
//Logger.debug(Type + ": ToggleActivation()");
//Logger.IncLvl();
Activated = !Activated;
//Logger.DecLvl();
}
public void PreventDefault(string keyCode)
{
//Logger.debug(Type + ": PreventDefault()");
//Logger.IncLvl();
if (!PreventDefaults.Contains(keyCode))
{
PreventDefaults.Add(keyCode);
}
//Logger.DecLvl();
}
public void AllowDefault(string keyCode)
{
//Logger.debug(Type + ": AllowDefault()");
//Logger.IncLvl();
if (PreventDefaults.Contains(keyCode))
{
PreventDefaults.Remove(keyCode);
}
//Logger.DecLvl();
}
public void FollowRoute(Route route)
{
//Logger.debug(Type + ": FollowRoute");
//Logger.IncLvl();
if (Parent != null)
{
Parent.FollowRoute(route);
}
//Logger.DecLvl();
}
public virtual Dictionary<string, string> GetValues(Func<XMLTree, bool> filter)
{
//Logger.log(Type + ": GetValues()");
//Logger.IncLvl();
Dictionary<string, string> dict = new Dictionary<string, string>();
string name = GetAttribute("name");
string value = GetAttribute("value");
if (name != null && value != null)
{
//Logger.log($"Added entry {{{name}: {value}}}");
dict[name] = value;
}
Dictionary<string, string> childDict;
foreach (XMLTree child in Children)
{
childDict = child.GetValues(filter);
foreach (string key in childDict.Keys)
{
if (!dict.ContainsKey(key))
{
dict[key] = childDict[key];
}
}
}
//Logger.DecLvl();
return dict;
}
/*public int GetWidth(int maxWidth)
{
//Logger.debug(Type + ".GetWidth()");
//Logger.IncLvl();
string attributeWidthValue = GetAttribute("width");
if (attributeWidthValue == null)
{
//Logger.DecLvl();
return 0;
//return maxWidth;
}
else
{
if (attributeWidthValue[attributeWidthValue.Length - 1] == '%')
{
//Logger.debug("is procent value (" + Single.Parse(attributeWidthValue.Substring(0, attributeWidthValue.Length - 1)).ToString() + ")");
//Logger.DecLvl();
return (int)(Single.Parse(attributeWidthValue.Substring(0, attributeWidthValue.Length - 1)) / 100f * maxWidth);
}
else if (maxWidth == 0)
{
//Logger.DecLvl();
return Int32.Parse(attributeWidthValue);
}
else
{
//Logger.DecLvl();
return Math.Min(maxWidth, Int32.Parse(attributeWidthValue));
}
}
}
public string RenderOld(int availableWidth)
{
//Logger.debug(Type + ".Render()");
//Logger.IncLvl();
List<string> segments = new List<string>();
int width = GetWidth(availableWidth);
PreRender(ref segments, width, availableWidth);
RenderText(ref segments, width, availableWidth);
string renderString = PostRender(segments, width, availableWidth);
//Logger.DecLvl();
return renderString;
}
public NodeBox Render(int availableWidth)
{
return Render(availableWidth, 0);
}
public NodeBox Render(int availableWidth, int availableHeight)
{
//Logger.debug(Type + ".Render()");
//Logger.IncLvl();
//Logger.DecLvl();
return Cache;
}
protected virtual void PreRender(ref List<string> segments, int width, int availableWidth)
{
//Logger.debug(Type + ".PreRender()");
//Logger.IncLvl();
//Logger.DecLvl();
}
protected virtual void RenderText(ref List<string> segments, int width, int availableWidth)
{
//Logger.debug(Type + ".RenderText()");
//Logger.IncLvl();
for (int i = 0; i < Children.Count; i++)
{
if (GetAttribute("flow") == "vertical")
{
string childString = RenderChild(Children[i], width);
if (childString != null)
{
if (i > 0 && Children[i - 1].Type == "textnode" && (Children[i].Type == "textnode" || Children[i].Type == "br"))
{
segments[segments.Count - 1] += childString;
}
else
{
segments.Add(childString);
}
}
else
{
}
}
else
{
string childString = RenderChild(Children[i], width);
if (childString != null)
{
availableWidth -= TextUtils.GetTextWidth(childString);
segments.Add(childString);
}
}
}
//Logger.DecLvl();
}
protected virtual string PostRender(List<string> segments, int width, int availableWidth)
{
//Logger.debug(Type + ".PostRender()");
//Logger.IncLvl();
string renderString = "";
string flowdir = GetAttribute("flow");
string alignChildren = GetAttribute("alignchildren");
string alignSelf = GetAttribute("alignself");
int totalWidth = 0;
foreach (string segment in segments)
{
int lineWidth = TextUtils.GetTextWidth(segment);
if (lineWidth > totalWidth)
{
totalWidth = lineWidth;
}
}
totalWidth = Math.Min(availableWidth, Math.Max(width, totalWidth));
if (flowdir == "vertical")
{
for (int i = 0; i < segments.Count; i++)
{
switch (alignChildren)
{
case "right":
segments[i] = TextUtils.PadText(segments[i], totalWidth, TextUtils.PadMode.LEFT);
break;
case "center":
segments[i] = TextUtils.CenterText(segments[i], totalWidth);
break;
default:
segments[i] = TextUtils.PadText(segments[i], totalWidth, TextUtils.PadMode.RIGHT);
break;
}
}
renderString = String.Join("\n", segments.ToArray());
}
else
{
renderString = String.Join("", segments.ToArray());
}
if (availableWidth - totalWidth > 0)
{
if (alignSelf == "center")
{
//Logger.log("Center element...");
renderString = TextUtils.CenterText(renderString, availableWidth);
}
else if (alignSelf == "right")
{
//Logger.log("Aligning element right...");
renderString = TextUtils.PadText(renderString, availableWidth, TextUtils.PadMode.RIGHT);
}
}
//Logger.DecLvl();
return renderString;
}

protected virtual string RenderChild(XMLTree child, int availableWidth)
{
//Logger.log(Type + ".RenderChild()");
//Logger.IncLvl();
//Logger.DecLvl();
return child.Render(availableWidth);
}*/
public void DetachChild(XMLTree child)
{
Children.Remove(child);
RerenderRequired = true;
}
public void Detach()
{
if(GetParent() != null)
{
GetParent().DetachChild(this);
}
}
/*protected virtual void BuildRenderCache()
{
//Logger.debug(Type + ".BuildRenderCache()");
//Logger.IncLvl();
//base.Clear();
NodeBoxTree box = this;
foreach (XMLTree child in Children)
{
box.Add(child);
}
RerenderRequired = false;
//Logger.DecLvl();
}*/
public virtual string Render(int containerWidth, int containerHeight)
{
//using (Logger logger = new Logger("XMLTree<" + Type + ">.Render(int, int)", Logger.Mode.LOG))
//{
//Logger.debug(Type + ".Render(int)");
//Logger.IncLvl();
//Logger.log("RENDERING::PREPARE");
IRenderBox cache = GetRenderBox(containerWidth, containerHeight);
//logger.log("Rendering::START", Logger.Mode.LOG);
//Logger.log("RENDERING::START");
string result = cache.Render(containerWidth, containerHeight);
//Logger.DecLvl();
return result;
//}
}
public string Render()
{
return Render(-1, -1);
}
}

public interface XMLParentNode
{
bool HasUserInputBindings { get; set; }
XMLParentNode GetParent();
void UpdateSelectability(XMLTree child);
void KeyPress(string keyCode);
void FollowRoute(Route route);
bool SelectNext();
void DetachChild(XMLTree child);
}

public static class TextUtils
{
public enum FONT { DEFAULT, MONOSPACE };
public static bool DEBUG = true;
private static FONT selectedFont = FONT.DEFAULT;
private static Dictionary<char, int> LetterWidths = new Dictionary<char, int>{
{ ' ', 8 }, { '!', 8 }, { '"', 10}, {'#', 19}, {'$', 20}, {'%', 24}, {'&', 20}, {'\'', 6}, {'(', 9}, {')', 9}, {'*', 11}, {'+', 18}, {',', 9}, {'-', 10}, {'.', 9}, {'/', 14}, {'0', 19}, {'1', 9}, {'2', 19}, {'3', 17}, {'4', 19}, {'5', 19}, {'6', 19}, {'7', 16}, {'8', 19}, {'9', 19}, {':', 9}, {';', 9}, {'<', 18}, {'=', 18}, {'>', 18}, {'?', 16}, {'@', 25}, {'A', 21}, {'B', 21}, {'C', 19}, {'D', 21}, {'E', 18}, {'F', 17}, {'G', 20}, {'H', 20}, {'I', 8}, {'J', 16}, {'K', 17}, {'L', 15}, {'M', 26}, {'N', 21}, {'O', 21}, {'P', 20}, {'Q', 21}, {'R', 21}, {'S', 21}, {'T', 17}, {'U', 20}, {'V', 20}, {'W', 31}, {'X', 19}, {'Y', 20}, {'Z', 19}, {'[', 9}, {'\\', 12}, {']', 9}, {'^', 18}, {'_', 15}, {'`', 8}, {'a', 17}, {'b', 17}, {'c', 16}, {'d', 17}, {'e', 17}, {'f', 9}, {'g', 17}, {'h', 17}, {'i', 8}, {'j', 8}, {'k', 17}, {'l', 8}, {'m', 27}, {'n', 17}, {'o', 17}, {'p', 17}, {'q', 17}, {'r', 10}, {'s', 17}, {'t', 9}, {'u', 17}, {'v', 15}, {'w', 27}, {'x', 15}, {'y', 17}, {'z', 16}, {'{', 9}, {'|', 6}, {'}', 9}, {'~', 18}, {' ', 8}, {'¡', 8}, {'¢', 16}, {'£', 17}, {'¤', 19}, {'¥', 19}, {'¦', 6}, {'§', 20}, {'¨', 8}, {'©', 25}, {'ª', 10}, {'«', 15}, {'¬', 18}, {'­', 10}, {'®', 25}, {'¯', 8}, {'°', 12}, {'±', 18}, {'²', 11}, {'³', 11}, {'´', 8}, {'µ', 17}, {'¶', 18}, {'·', 9}, {'¸', 8}, {'¹', 11}, {'º', 10}, {'»', 15}, {'¼', 27}, {'½', 29}, {'¾', 28}, {'¿', 16}, {'À', 21}, {'Á', 21}, {'Â', 21}, {'Ã', 21}, {'Ä', 21}, {'Å', 21}, {'Æ', 31}, {'Ç', 19}, {'È', 18}, {'É', 18}, {'Ê', 18}, {'Ë', 18}, {'Ì', 8}, {'Í', 8}, {'Î', 8}, {'Ï', 8}, {'Ð', 21}, {'Ñ', 21}, {'Ò', 21}, {'Ó', 21}, {'Ô', 21}, {'Õ', 21}, {'Ö', 21}, {'×', 18}, {'Ø', 21}, {'Ù', 20}, {'Ú', 20}, {'Û', 20}, {'Ü', 20}, {'Ý', 17}, {'Þ', 20}, {'ß', 19}, {'à', 17}, {'á', 17}, {'â', 17}, {'ã', 17}, {'ä', 17}, {'å', 17}, {'æ', 28}, {'ç', 16}, {'è', 17}, {'é', 17}, {'ê', 17}, {'ë', 17}, {'ì', 8}, {'í', 8}, {'î', 8}, {'ï', 8}, {'ð', 17}, {'ñ', 17}, {'ò', 17}, {'ó', 17}, {'ô', 17}, {'õ', 17}, {'ö', 17}, {'÷', 18}, {'ø', 17}, {'ù', 17}, {'ú', 17}, {'û', 17}, {'ü', 17}, {'ý', 17}, {'þ', 17}, {'ÿ', 17}, {'Ā', 20}, {'ā', 17}, {'Ă', 21}, {'ă', 17}, {'Ą', 21}, {'ą', 17}, {'Ć', 19}, {'ć', 16}, {'Ĉ', 19}, {'ĉ', 16}, {'Ċ', 19}, {'ċ', 16}, {'Č', 19}, {'č', 16}, {'Ď', 21}, {'ď', 17}, {'Đ', 21}, {'đ', 17}, {'Ē', 18}, {'ē', 17}, {'Ĕ', 18}, {'ĕ', 17}, {'Ė', 18}, {'ė', 17}, {'Ę', 18}, {'ę', 17}, {'Ě', 18}, {'ě', 17}, {'Ĝ', 20}, {'ĝ', 17}, {'Ğ', 20}, {'ğ', 17}, {'Ġ', 20}, {'ġ', 17}, {'Ģ', 20}, {'ģ', 17}, {'Ĥ', 20}, {'ĥ', 17}, {'Ħ', 20}, {'ħ', 17}, {'Ĩ', 8}, {'ĩ', 8}, {'Ī', 8}, {'ī', 8}, {'Į', 8}, {'į', 8}, {'İ', 8}, {'ı', 8}, {'Ĳ', 24}, {'ĳ', 14}, {'Ĵ', 16}, {'ĵ', 8}, {'Ķ', 17}, {'ķ', 17}, {'Ĺ', 15}, {'ĺ', 8}, {'Ļ', 15}, {'ļ', 8}, {'Ľ', 15}, {'ľ', 8}, {'Ŀ', 15}, {'ŀ', 10}, {'Ł', 15}, {'ł', 8}, {'Ń', 21}, {'ń', 17}, {'Ņ', 21}, {'ņ', 17}, {'Ň', 21}, {'ň', 17}, {'ŉ', 17}, {'Ō', 21}, {'ō', 17}, {'Ŏ', 21}, {'ŏ', 17}, {'Ő', 21}, {'ő', 17}, {'Œ', 31}, {'œ', 28}, {'Ŕ', 21}, {'ŕ', 10}, {'Ŗ', 21}, {'ŗ', 10}, {'Ř', 21}, {'ř', 10}, {'Ś', 21}, {'ś', 17}, {'Ŝ', 21}, {'ŝ', 17}, {'Ş', 21}, {'ş', 17}, {'Š', 21}, {'š', 17}, {'Ţ', 17}, {'ţ', 9}, {'Ť', 17}, {'ť', 9}, {'Ŧ', 17}, {'ŧ', 9}, {'Ũ', 20}, {'ũ', 17}, {'Ū', 20}, {'ū', 17}, {'Ŭ', 20}, {'ŭ', 17}, {'Ů', 20}, {'ů', 17}, {'Ű', 20}, {'ű', 17}, {'Ų', 20}, {'ų', 17}, {'Ŵ', 31}, {'ŵ', 27}, {'Ŷ', 17}, {'ŷ', 17}, {'Ÿ', 17}, {'Ź', 19}, {'ź', 16}, {'Ż', 19}, {'ż', 16}, {'Ž', 19}, {'ž', 16}, {'ƒ', 19}, {'Ș', 21}, {'ș', 17}, {'Ț', 17}, {'ț', 9}, {'ˆ', 8}, {'ˇ', 8}, {'ˉ', 6}, {'˘', 8}, {'˙', 8}, {'˚', 8}, {'˛', 8}, {'˜', 8}, {'˝', 8}, {'Ё', 19}, {'Ѓ', 16}, {'Є', 18}, {'Ѕ', 21}, {'І', 8}, {'Ї', 8}, {'Ј', 16}, {'Љ', 28}, {'Њ', 21}, {'Ќ', 19}, {'Ў', 17}, {'Џ', 18}, {'А', 19}, {'Б', 19}, {'В', 19}, {'Г', 15}, {'Д', 19}, {'Е', 18}, {'Ж', 21}, {'З', 17}, {'И', 19}, {'Й', 19}, {'К', 17}, {'Л', 17}, {'М', 26}, {'Н', 18}, {'О', 20}, {'П', 19}, {'Р', 19}, {'С', 19}, {'Т', 19}, {'У', 19}, {'Ф', 20}, {'Х', 19}, {'Ц', 20}, {'Ч', 16}, {'Ш', 26}, {'Щ', 29}, {'Ъ', 20}, {'Ы', 24}, {'Ь', 19}, {'Э', 18}, {'Ю', 27}, {'Я', 20}, {'а', 16}, {'б', 17}, {'в', 16}, {'г', 15}, {'д', 17}, {'е', 17}, {'ж', 20}, {'з', 15}, {'и', 16}, {'й', 16}, {'к', 17}, {'л', 15}, {'м', 25}, {'н', 16}, {'о', 16}, {'п', 16}, {'р', 17}, {'с', 16}, {'т', 14}, {'у', 17}, {'ф', 21}, {'х', 15}, {'ц', 17}, {'ч', 15}, {'ш', 25}, {'щ', 27}, {'ъ', 16}, {'ы', 20}, {'ь', 16}, {'э', 14}, {'ю', 23}, {'я', 17}, {'ё', 17}, {'ђ', 17}, {'ѓ', 16}, {'є', 14}, {'ѕ', 16}, {'і', 8}, {'ї', 8}, {'ј', 7}, {'љ', 22}, {'њ', 25}, {'ћ', 17}, {'ќ', 16}, {'ў', 17}, {'џ', 17}, {'Ґ', 15}, {'ґ', 13}, {'–', 15}, {'—', 31}, {'‘', 6}, {'’', 6}, {'‚', 6}, {'“', 12}, {'”', 12}, {'„', 12}, {'†', 20}, {'‡', 20}, {'•', 15}, {'…', 31}, {'‰', 31}, {'‹', 8}, {'›', 8}, {'€', 19}, {'™', 30}, {'−', 18}, {'∙', 8}, {'□', 21}, {'', 40}, {'', 40}, {'', 40}, {'', 40}, {'', 41}, {'', 41}, {'', 32}, {'', 32}, {'', 40}, {'', 40}, {'', 34}, {'', 34}, {'', 40}, {'', 40}, {'', 40}, {'', 41}, {'', 32}, {'', 41}, {'', 32}, {'', 40}, {'', 40}, {'', 40}, {'', 40}, {'', 40}, {'', 40}, {'', 40}, {'', 40}
};
public enum PadMode { LEFT, RIGHT, BOTH };
public enum RoundMode { FLOOR, CEIL };
public static void SelectFont(FONT f)
{
selectedFont = f;
}
public static void Reset()
{
selectedFont = FONT.DEFAULT;
}
public static int GetCharWidth(char c)
{
if(selectedFont == FONT.MONOSPACE)
{
return 24;
}

int v = 0;
if (LetterWidths.ContainsKey(c)) return LetterWidths[c];
return 8;
}
public static int GetTextWidth(string text)
{
return GetTextWidth(text, 0, text.Length);
}
public static int GetTextWidth(string text, int start, int length)
{
//using (new SimpleProfiler("TextUtils.GetTextWidth(StringBuilder, int, int)"))
//{
string[] lines = text.Substring(start, length).Split('\n');
if (start + length > text.Length)
{
throw new Exception("ERROR: stringbuilder slice exceeds the stringbuilders length!");
}
text = text.Replace("\r", "");
int width = 0;
int lineWidth = 0;
foreach(string line in lines)
{
if (selectedFont == FONT.MONOSPACE)
{
lineWidth = (line.Length * 25);
}
else
{
lineWidth = line.Select(c => LetterWidths.GetValueOrDefault(c, 6)).Sum() + line.Length;
}
width = Math.Max(lineWidth - 1, width);
lineWidth = 0;
}
return Math.Max(width, lineWidth - 1);
//}
}
/*public static string RemoveLastTrailingNewline(string text)
{
//Logger.debug("TextUtils.RemoveLastTrailingNewline");
//Logger.IncLvl();
//Logger.DecLvl();
return (text.Length > 1 && text[text.Length - 1] == '\n') ? text.Remove(text.Length - 1) : text;
}
public static string RemoveFirstTrailingNewline(string text)
{
//Logger.debug("TextUtils.RemoveFirstTrailingNewline");
//Logger.IncLvl();
//Logger.DecLvl();
return (text.Length > 1 && text[0] == '\n') ? text.Remove(0) : text;
}*/
public static StringBuilder CreateStringOfLength(char constituent, int length)
{
return CreateStringOfLength(constituent, length, RoundMode.FLOOR);
}
public static StringBuilder CreateStringOfLength(char constituent, int length, RoundMode mode)
{
//using (new SimpleProfiler("TextUtils.CreateStringOfLength(string, int, RoundMode)"))
//{
int lengthOfConstituent = GetCharWidth(constituent);
if (mode == RoundMode.CEIL)
{
//Logger.log("Ceil mode", Logger.Mode.DEBUG);
length += lengthOfConstituent;
}
StringBuilder result = new StringBuilder();
if (length < lengthOfConstituent)
{
return new StringBuilder();
}
int numberOfChars = (length + 1) / (lengthOfConstituent + 1);
return new StringBuilder(new string(constituent, numberOfChars));
//}
}
public static StringBuilder PadText(string text, int totalWidth, PadMode mode)
{
return PadText(text, totalWidth, mode, ' ');
}
public static StringBuilder PadText(string text, int totalWidth, PadMode mode, char padChar)
{
//using (new SimpleProfiler("TextUtils.PadText(StringBuilder, int, PadMode, string)"))
//{
string[] lines = text.Split('\n');
StringBuilder result = new StringBuilder();
StringBuilder padding = new StringBuilder();
int width;
int lineStart;
int lineEnd = -1;
foreach (string line in lines)
{
width = GetTextWidth(line) + 1;
if (mode == PadMode.BOTH)
{
padding = CreateStringOfLength(padChar, (totalWidth - width) / 2);
result.Append(padding);
result.Append(line);
result.Append(padding);
}
else
{
padding = CreateStringOfLength(padChar, totalWidth - width);
if (mode == PadMode.LEFT)
{
result.Append(padding);
result.Append(line);
}
else
{
result.Append(line);
result.Append(padding);
}
}
result.Append("\n");
}
if (result.Length > 0)
result.Remove(result.Length - 1, 1);
return result;
//}
}
public static string SubstringOfWidth(string str, int width, int offset=0)
{
if (str.Length == 0)
return str;
if (selectedFont == FONT.MONOSPACE)
{
return str.Substring(offset, Math.Min(str.Length - offset, (width + 1) / 25));
}
else
{
string result = "";
int currentWidth = 0;
for (int i = offset; i < str.Length; i++)
{
width += LetterWidths.GetValueOrDefault(str[i], 6) + 1;
if (currentWidth - 1 > width)
result = str.Substring(offset, i - 1);
}
return result;
}
}
}

public class Logger : IDisposable
{
public enum Mode { DEBUG, LOG, ERROR, WARNING, CONSOLE};
private static StringBuilder Log = new StringBuilder();
static public bool DEBUG = false;
protected static StringBuilder Prefix = new StringBuilder();
protected Program Prog;
protected Mode logMode;
private bool disposed;
public static string Output
{
get { return Log.ToString(); }
}
public Logger(string message) : this(message, Mode.DEBUG) {}
public Logger(string message, Mode mode) : this(message, mode, null) {}
public Logger(string message, Mode mode, Program program)
{
disposed = false;
if (!DEBUG && mode == Mode.DEBUG)
return;
Prog = program;
logMode = mode;
log(message, logMode);
IncLvl();
}
public void log(string message, Mode mode)
{
log(new StringBuilder(message), mode);
}
public void log(string message)
{
log(new StringBuilder(message));
}
public void log(StringBuilder message)
{
log(message, logMode);
}
public void log(StringBuilder message, Mode mode)
{
StringBuilder msg = new StringBuilder().Append(Prefix);
if (mode != Mode.LOG && mode != Mode.CONSOLE)
msg.Append(mode.ToString()).Append(": ");
msg.Append(message);
Log.Append(msg).Append("\n");
if (mode == Mode.CONSOLE)
{
if(Prog != null)
Prog?.Echo(msg.ToString());
}
}
private void IncLvl()
{
Prefix.Append("  ");
}
private void DecLvl()
{
if( Prefix.Length >= 2)
Prefix.Remove(Prefix.Length - 2, 2);
}

public virtual void Dispose()
{
if (!disposed)
{
DecLvl();
}
disposed = true;
}
public static void Clear()
{
Log = new StringBuilder();
}
}

public abstract class IRenderBox
{
protected bool minHeightIsCached;
protected bool minWidthIsCached;
protected bool desiredHeightIsCached;
protected bool desiredWidthIsCached;
protected int minHeightCache;
protected int minWidthCache;
protected int desiredHeightCache;
protected int desiredWidthCache;
public bool DEBUG = false;
public char PadChar;
public InitializationState InitState;
public enum TextAlign { LEFT, RIGHT, CENTER }
public enum FlowDirection { HORIZONTAL, VERTICAL }

//public abstract int Height { get; set; }
public abstract void Add(string box);
public abstract void Add(StringBuilder box);
public abstract void AddAt(int position, string box);
public abstract void AddAt(int position, StringBuilder box);
public abstract StringBuilder GetLine(int index);
public abstract StringBuilder GetLine(int index, int maxWidth, int maxHeight);
public abstract void Clear();
public abstract void Initialize(int maxWidth, int maxHeight);
public abstract void CalculateDimensions(int maxWidth, int maxHeight);
private IRenderBox.FlowDirection _Flow;
private IRenderBox.TextAlign _Align;
public int _MinWidth;
public int _MaxWidth;
public int _DesiredWidth;
public int _MinHeight;
public int _MaxHeight;
public int _DesiredHeight;
public IRenderBox Parent;
public string type;
private bool RenderingInProcess;
public string MinWidthDef;
public string MaxWidthDef;
public string MinHeightDef;
public string MaxHeightDef;
public string DesiredWidthDef;
public string DesiredHeightDef;
public virtual int GetActualWidth(int maxWidth)
{
//using (Logger logger = new Logger("RenderBox.GetActualWidth(int)", Logger.Mode.LOG))
//{
//logger.log("Type: " + type, Logger.Mode.LOG);
//if (this as RenderBoxLeaf != null)
//    logger.log("content: |" + (this as RenderBoxLeaf).Content + "|", Logger.Mode.LOG);
// logger.log("implicit max width: " + maxWidth, Logger.Mode.LOG);
// logger.log("explicit max width: " + MaxWidth, Logger.Mode.LOG);
//logger.log("min width: " + MinWidth, Logger.Mode.LOG);
//logger.log("desired width: " + DesiredWidth, Logger.Mode.LOG);
maxWidth = Math.Min(MaxWidth, maxWidth);

int desired;
desired = Math.Max(DesiredWidth, MinWidth);
desired = Math.Min(desired, maxWidth);
return desired;
//}
}
public int GetIndependentWidth(int maxWidth)
{
//using (Logger logger = new Logger("RenderBoxTree.GetIndependentWidth(int)", Logger.Mode.LOG))
//{
//logger.log("Type: " + type, Logger.Mode.LOG);
//logger.log("implicit max width: " + maxWidth, Logger.Mode.LOG);
//logger.log("explicit max width: " + MaxWidth, Logger.Mode.LOG);
//logger.log("min width: " + _MinWidth, Logger.Mode.LOG);
//logger.log("desired width: " + DesiredWidth, Logger.Mode.LOG);
maxWidth = Math.Min(MaxWidth, maxWidth);
int desired;
desired = Math.Max(DesiredWidth, _MinWidth);
desired = Math.Min(desired, maxWidth);
return desired;
//}
}
public int GetActualHeight(int maxHeight)
{
//using (Logger logger = new Logger("RenderBox.GetActualHeight(int)", Logger.Mode.LOG))
//{
//logger.log("Type: " + type, Logger.Mode.LOG);
//logger.log("implicit max height: " + maxHeight, Logger.Mode.LOG);
//logger.log("explicit max height: " + MaxHeight, Logger.Mode.LOG);
maxHeight = Math.Min(MaxHeight, maxHeight);

int desired = DesiredHeight == -1 ? MinHeight : Math.Max(MinHeight, DesiredHeight);
//Logger.DecLvl();
//logger.log("maxheight: " + maxHeight, Logger.Mode.LOG);
//logger.log("minheight: " + MinHeight, Logger.Mode.LOG);
//logger.log("Desired Height: " + DesiredHeight, Logger.Mode.LOG);
//logger.log("actual height: " + Math.Min(desired, maxHeight) + " (min( " + desired + ", " + maxHeight + ")", Logger.Mode.LOG);
return Math.Max(0, Math.Min(desired, maxHeight));
//}
}
public IRenderBox.TextAlign Align
{
get { return _Align; }
set
{
_Align = value;
}
}
public virtual IRenderBox.FlowDirection Flow
{
get { return _Flow; }
set
{
_Flow = value;
ClearCache();
}
}
public virtual int MinWidth
{
get
{
return _MinWidth;
}
set
{
_MinWidth = Math.Max(0, value);
ClearCache();
}
}
public virtual int DesiredWidth
{
get
{
return _DesiredWidth;
}
set
{
_DesiredWidth = value;
}
}
public virtual int MaxWidth
{
get
{
return _MaxWidth;
}
set
{
if (value < 0)
_MaxWidth = int.MaxValue;
else
_MaxWidth = value;
}
}
public virtual int MinHeight
{
get
{
return _MinHeight;
}
set
{
_MinHeight = Math.Max(0, value);
ClearCache();
}
}
public virtual int DesiredHeight
{
get
{
return _DesiredHeight;
}
set
{
_DesiredHeight = value;
}
}
public int MaxHeight
{
get
{
return _MaxHeight;
}
set
{
if (value < 0)
_MaxHeight = int.MaxValue;
else
_MaxHeight = value;
ClearCache();
}
}
public IRenderBox()
{
PadChar = ' ';
_Flow = IRenderBox.FlowDirection.VERTICAL;
_Align = IRenderBox.TextAlign.LEFT;
_MinWidth = 0;
_MaxWidth =  int.MaxValue;
_DesiredWidth = -1;
_MinHeight = 0;
_MaxHeight = int.MaxValue;
_DesiredHeight = -1;
minHeightIsCached = false;
minWidthIsCached = false;
desiredHeightIsCached = false;
desiredWidthIsCached = false;
InitState = new InitializationState();
}
public bool IsRenderingInProgress()
{
return RenderingInProcess || (Parent?.IsRenderingInProgress() ?? false);
}
public virtual IEnumerable<StringBuilder> GetLines(int maxWidth, int maxHeight)
{
int height = GetActualHeight(maxHeight);
for (int i = 0; i < height; i++)
{
yield return GetLine(i, maxWidth, maxHeight);
}
}
public IEnumerable<StringBuilder> GetLines()
{
int height = GetActualHeight(int.MaxValue);
for (int i = 0; i < height; i++)
{
yield return GetLine(i, int.MaxValue, int.MaxValue);
}
}
protected void AlignLine(ref StringBuilder line)
{
AlignLine(ref line, int.MaxValue);
}
protected void AlignLine(ref StringBuilder line, int maxWidth)
{
AlignLine(ref line, maxWidth, Align, PadChar);
}
protected void AlignLine(ref StringBuilder line, IRenderBox.TextAlign Alignment)
{
AlignLine(ref line, int.MaxValue, Alignment, PadChar);
}
protected void AlignLine(ref StringBuilder line, int maxWidth, IRenderBox.TextAlign Alignment, char padChar)
{
//using (Logger logger = new Logger("RenderBox.AlignLine(ref StringBuilder, int)", Logger.Mode.LOG))
//{
//logger.log("Type: " + type);
//logger.log("pad char is: " + padChar);
//logger.log("this.PadChar is: " + PadChar);
//logger.log("max width is " + maxWidth, Logger.Mode.LOG);
int actualWidth = GetActualWidth(maxWidth);
//logger.log("actualWidth: " + actualWidth, Logger.Mode.LOG);
//logger.log("line is: |" + line + "|", Logger.Mode.LOG);
//logger.log("line width: " + TextUtils.GetTextWidth(line.ToString()));
int remainingWidth = actualWidth - TextUtils.GetTextWidth(line.ToString());
//logger.log("remaining width is " + remainingWidth, Logger.Mode.LOG);
//logger.log("Aligning " + _Align.ToString() + "...");
if (remainingWidth > 0) // line is not wide enough; padding necessary
{
//logger.log("padding...", Logger.Mode.LOG);
switch (Alignment)
{
case TextAlign.CENTER:
line = TextUtils.PadText(line.ToString(), actualWidth, TextUtils.PadMode.BOTH, padChar);
break;
case TextAlign.RIGHT:
line = TextUtils.PadText(line.ToString(), actualWidth, TextUtils.PadMode.LEFT, padChar);
break;
default:
line = TextUtils.PadText(line.ToString(), actualWidth, TextUtils.PadMode.RIGHT, padChar);
break;
}
}
else if (remainingWidth < 0)
{
//logger.log("clipping", Logger.Mode.LOG);
line = new StringBuilder(line.ToString());
while (remainingWidth < 0)
{
remainingWidth += TextUtils.GetTextWidth(new string(new char[] { line[line.Length - 1] })) + 1;
line.Remove(line.Length - 1, 1);
}
}
else
{
//logger.log("neither padding nor clipping...", Logger.Mode.LOG);
}
//logger.log("aligned line is: {" + line + "}", Logger.Mode.LOG);
//}
}
public string Render(int maxWidth, int maxHeight)
{
Initialize(maxWidth, maxHeight);
StringBuilder result = new StringBuilder();
foreach (StringBuilder line in GetLines(maxWidth, maxHeight))
{
result.Append(line);
result.Append("\n");
}
if (result.Length > 0)
result.Remove(result.Length - 1, 1);
return result.ToString();
}
public void ClearCache()
{
minHeightIsCached = false;
minWidthIsCached = false;
if (Parent != null)
Parent?.ClearCache();
}
public static int? ResolveSize(string widthString, int max)
{
if (widthString == null)
return null;
widthString = widthString?.Trim();
if (widthString[widthString.Length - 1] == '%' && Single.TryParse(widthString.Substring(0, widthString.Length - 1), out float fWidth))
{
if (max < 0 || max == int.MaxValue)
return null;
return (int)(fWidth / 100f * Math.Max(0, max));
}
else
{
int iWidth;
if (int.TryParse(widthString, out iWidth))
return iWidth;
return -1;
}
}
}


}